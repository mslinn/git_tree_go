#!/bin/bash
# Release script for git-tree-go
# Usage: ./scripts/release [-s] [-d] [version]
# Example: ./scripts/release 1.2.3

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Options ---
SKIP_TESTS=false
DEBUG_MODE=false

get_next_version() {
  local latest_tag
  latest_tag=$(git describe --tags --abbrev=0 2>/dev/null)
  if [[ -z "$latest_tag" ]]; then
    echo "0.1.0"
    return
  fi
  local version_number=${latest_tag#v} # remove v prefix
  local next_version
  next_version=$(echo "$version_number" | awk -F. -v OFS=. '{$3++; print}')
  echo "$next_version"
}

usage() {
  local next_version
  next_version=$(get_next_version)
  echo "Release a new version to GitHub"
  echo ""
  echo "Usage: $(basename $0) [OPTIONS] [VERSION]"
  echo ""
  echo "  OPTIONS:"
  echo "    -d: Run GoReleaser in debug mode in the CI workflow"
  echo "    -h: Display this help message"
  echo "    -s: Skip running integration tests"
  echo ""
  echo "  VERSION: The version to release (e.g., $next_version)"
  exit 0
}

# Function to print colored messages
info() {
  echo -e "${BLUE}ℹ${NC}  $1"
}

success() {
  echo -e "${GREEN}✓${NC}  $1"
}

warning() {
  echo -e "${YELLOW}⚠${NC}  $1"
}

error() {
  echo -e "${RED}✗${NC}  $1"
  exit 1
}

# Function to validate semantic version
validate_version() {
  local version=$1
  if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    error "Invalid version format: $version (expected: X.Y.Z)"
  fi
}

# Check if on main branch
check_branch() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
    warning "You are on branch '$current_branch', not main/master"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      error "Aborted"
    fi
  fi
}

# Check for uncommitted changes
check_clean() {
  if [[ -n $(git status -s) ]]; then
    warning "Working directory is not clean. Committing..."
    git add -A
    git commit -am 'Committing leftovers'
    git push origin
  fi
  success "Working directory is clean"
}

# Check if tag already exists
check_tag() {
  local version=$1
  if git rev-parse "v$version" >/dev/null 2>&1; then
    error "Tag v$version already exists"
  fi
  success "Tag v$version is available"
}

# Run tests
run_tests() {
  if [ "$SKIP_TESTS" = true ]; then
    warning "Skipping integration tests."
    return
  fi
  info "Running tests..."
  if make test:spec -short 2>/dev/null; then
    success "All tests passed"
  else
    error "Tests failed. Fix issues before releasing."
  fi
}

# Update version in files (if needed)
update_version_files() {
  local version=$1
  # Add version updates here if version is stored in any files
  # For now, this is a placeholder
  info "Version will be v$version"
}

# Create and push tag
create_tag() {
  local version=$1
  local tag="v$version"
  local tag_message="Release $tag"

  if [ "$DEBUG_MODE" = true ]; then
    tag_message+=$'\n\n[debug]'
    warning "GoReleaser will run in debug mode in the CI workflow."
  fi

  info "Creating tag $tag..."
  git tag -a "$tag" -m "$tag_message"
  success "Tag $tag created"

  info "Pushing tag to origin..."
  git push origin "$tag"
  success "Tag pushed to origin"

  echo ""
  info "Release workflow has been triggered"
  info "Check progress at: https://github.com/$(git config --get remote.origin.url | sed 's/.*github.com[:/]\(.*\)\.git/\1/')/actions"
}

# Show current version
show_current_version() {
  local latest_tag
  latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
  info "The most recent version tag is $latest_tag."
}

# Main script
main() {
  # Parse options
  while getopts "hsd" opt; do
    case ${opt} in
      h ) usage ;;
      s ) SKIP_TESTS=true ;;
      d ) DEBUG_MODE=true ;;
      \? ) usage ;;
    esac
done
  shift $((OPTIND -1))

  echo "=================================="
  echo "  git-tree-go Release Script"
  echo "=================================="
  echo ""

  # Show current version
  show_current_version
  echo ""

  # Get version from argument or prompt
  local version=$1
  local next_version
  next_version=$(get_next_version)
  if [[ -z "$version" ]]; then
    read -rp "What version number should this release have (accept the default with Enter) [$next_version] " version
    version=${version:-$next_version}
  fi

  # Validate version
  validate_version "$version"
  success "Version format is valid: $version"

  # Run checks
  check_branch
  check_clean
  check_tag "$version"

  # Run tests
  run_tests

  # Update version files
  update_version_files "$version"

  # Confirm release
  echo ""
  read -p "Proceed with release v$version? (Y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    error "Release cancelled"
  fi

  # Create and push tag
  create_tag "$version"

  echo ""
  success "Release v$version initiated successfully!"
  echo ""
  info "Next steps:"
  echo "  1. Monitor the GitHub Actions workflow"
  echo "  2. Verify the release on GitHub"
  echo "  3. Test the release binaries"
  echo "  4. Announce the release (if applicable)"
  echo ""
}

# Run main function
main "$@"
